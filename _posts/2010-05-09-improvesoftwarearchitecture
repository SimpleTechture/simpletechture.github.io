---
layout: post
title: Improve your Software Architecture
tags:
- Architecture
- Software Architecture
---

<p style="text-align: justify;">You can improve the quality of your <strong>Software Architecture Design</strong> by using the following 10 tips. I use these 10 tips or guidelines daily and they have helped me creating <strong>high quality</strong> Software Architectures. Describing your software architecture design is useful for any type of project, it will share the design of the system among your stakeholder.</p>
<p>My 10 ways:<span id="more-631"></span></p>
<ol>
<li>Based on non functional requirements </li>
<li>Rationale, rationale, rationale </li>
<li>Don’t Repeat Yourself </li>
<li>Slice the cake </li>
<li>Prototype </li>
<li>Quantify </li>
<li>Get it working, Get it right, Get it optimized </li>
<li>Focus on the boundaries and interfaces </li>
<li>The Perfect is the enemy of the Good </li>
<li>Align with your stakeholders </li>
</ol>
<p><strong>1. Based on requirements</strong></p>
<p style="text-align: justify;">You should base your <strong>software architecture design</strong> on the requirements of your <strong>stakeholders</strong>. An architecture focuses on the <strong>non-functional requirements</strong>. I see many software architecture designs based on purely technical motives. Each part of your design should be based on business requirements. You as an architect should translate these requirements into the right <strong>architectural design decisions</strong>. If the stakeholder values <strong>maintainability</strong>, you could use the <strong>layer pattern</strong> to separate several parts of the application. If <strong>performance</strong> is important, maybe layering is not a good solution. An exhaustive list of non-functional requirements can be found at <a target="_blank" href="http://en.wikipedia.org/wiki/ISO/IEC_9126" title="SO/IEC 9126 Software engineering - Product quality">ISO 9126</a> and at <a target="_blank" href="http://www.serc.nl/quint-book/" title="QUINT Software Quality Attributes">QUINT</a>. If you do not use Non-functional requirements in your organization but want to introduce them,&nbsp; take a look at <a target="_blank" href="http://www.semanticarchitecture.net/post-with-picture/non-functional-requirements-define-a-software-architecture" title="How to introduce Non-functional requirements">this post</a>.</p>
<p style="text-align: justify;"><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Requirements.jpg"><img width="398" height="302" src="79994/Requirements1.jpg" /></a> </p><p style="text-align: justify;">From the Non-functional requirements or <strong>quality attributes</strong> you have to create the right design. While you could create this from scratch there are many examples in the form of <strong>design patterns</strong> or <strong>architectural patterns. </strong>A design or architectural pattern expresses a relation between a problem and a solution. Although we often think that our problem is unique this is often not the case. If you take a step back you will see that many of our problems already have been solved using existing patterns. Two books that I can recommend are <a target="_blank" href="http://www.amazon.com/Pattern-Oriented-Software-Architecture-System-Patterns/dp/0471958697" title="POSA Pattern-Oriented Software Architecture">“Pattern-Oriented Software Architecture”</a> and <a target="_blank" href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" title="Design Patterns: Elements of Reusable Object-Oriented Software">“Design Patterns”</a>. Both books contain a catalog patterns. Each pattern describes the problem it solves and in which context it can be used. There are also many <strong>online</strong> pattern source on the web such as <a target="_blank" href="http://en.wikipedia.org/wiki/Architectural_pattern_(computer_science)" title="Architectural patterns on WikipediA">this one on Wikipedia</a> and <a target="_blank" href="http://www.opengroup.org/architecture/togaf8-doc/arch/chap28.html" title="Architectural patterns from the OpenGroup">this from The OpenGROUP</a></p>
<p><strong>2. Rationale, rationale, rationale</strong></p>
<p style="text-align: justify;">The most important aspect of your <strong>architecture description</strong> is the recording of your <strong>rationale</strong> behind your <strong>design decisions</strong>. It is important for a <strong>reader</strong> of the architecture description to understand the reason why you made a specific decision. Make your assumptions explicit and add them to the description. Assumptions may be invalid now or later but at least it will be clear how you came to that decision. It make communicating with your team (you do communicate do you?) that much easier if you share you rationale.</p>
<p><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Rationale.jpg"><img width="425" height="282" src="79994/Rationale1.jpg" /></a></p>
<p style="text-align: justify;">Note that recording your rationale become much easier if your non-functional requirements are explicit. It will be much clearer if you describe that you created several components to increase the <strong>testability </strong>because testability is the most important requirements. Do describe the <strong>Why</strong> and <strong>How</strong> in your<strong> software architecture design!</strong></p>
<p><strong>3. Don’t Repeat Yourself (DRY)</strong></p>
<p style="text-align: justify;">Don’t Repeat Yourself (DRY) or <strong>Duplication Is Evil (DIE)</strong> come from software-engineering in general. The DRY principle is stated as “Every piece of knowledge must have a <strong>single</strong>, unambiguous, authoritative representation within a system”. You can apply this principle on <strong>many levels</strong>; Architecture, Design, Testing, Source Code and Data. For me this is one of the most <strong>difficult</strong> things to uphold. You have to fight the repetition because it will slow you and your project down. The difficult part of this <strong>Repetition Creep</strong> as I call it is that it is introduces <strong>very slowly</strong>. The first repetition won’t hurt you directly, it will even gain some time. You are able to release the first version of the application somewhat quicker, but as I found it <strong>always</strong> shows up later and makes something else <strong>more difficult</strong>. At that moment you <strong>regret</strong> the decision to introduce repetition.</p>
<p><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Repetition.jpg"><img width="490" height="197" src="79994/Repetition.jpg" /></a></p>
<p style="text-align: justify;">If you absolutely must add another copy of information make sure that you <strong>automatically generate </strong>that copy of the information. It will make your live so much easier in the future. One thing that helps to fight repetition is to store the data where it belongs. This seems logical and is the basis of <strong>object oriented design</strong> but I often see this <strong>violated</strong> with regards to system architectures. For example take <strong>packaging</strong> an application for <strong>deployment</strong>. The process in which you filter the build of your software to include the components that are necessary in a package. Where <strong>would you store</strong> the information which component should be included in the package? You could <strong>create a list</strong> that includes the names of the components that should be packaged. That means you <strong>introduce</strong> your first <strong>repetition</strong>! You now have two places where component names are mentioned. A better solution would be to add that information to the component itself.</p>
<p style="text-align: justify;">When the first list in any format shows up in or around an application, <strong>alarm bells</strong> should sound and you should be on the lookout for repetition!</p>
<p><strong>4. Slice the cake</strong></p>
<p style="text-align: justify;">I struggled with naming this, but found <strong>Slicing the cake</strong> as it is called in <strong>Agile development</strong> the best description. By slicing the cake I mean that you design your architecture <strong>iterative</strong> in <strong>vertical slices</strong>. An architect implements or prototypes each vertical slice to confirm if it actually works. You should do this because architectures <strong>cannot</strong> be created on <strong>paper</strong>. It does not mean that you cannot use horizontal layering or any other pattern in your architecture. In the case of layering the horizontal layers are smaller. The picture below shows the principle.</p>
<p style="text-align: justify;"><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Slicingthecake1.png"><img width="600" height="200" src="79994/Slicingthecake.png" /></a> </p><p style="text-align: justify;">Say you use <strong>layering</strong> in your architecture design because your stakeholders expect that the components that you develop for this system will be used in other systems as well. During the first iteration you design a small part of the User Interface (UI), a small part of the Business Layer (BL) and a small part of the Data Layer (DL). You make sure that this works as expected by <strong>proving</strong> it with a <strong>prototype</strong> or by actually implementing it. In the second iteration you add new functionality and <strong>expand</strong> each layer <strong>horizontally</strong> with the needed functionality. The existing UI, BL and DL are <strong>combined</strong> with the new UI, BL and DL to form the new layers.</p>
<p style="text-align: justify;">The difficulty with slicing is how to slice the cake so that the next slice will properly align with the previous.</p>
<p><strong>5. Prototype</strong></p>
<p style="text-align: justify;">When creating a software architecture design make sure that you prototype your design. Validate your assumptions, do that performance test and make sure that the security architecture is valid. A prototype will give you the opportunity to fail fast which is a good thing.</p>
<p><strong>6. Quantify</strong></p>
<p style="text-align: justify;">This principle extends&nbsp;the first principle “Based on Requirements”. To be able to create a proper software architecture design you need to quantify your Non-functional requirements. It should be “fast” cannot be a requirement neither is maintainable or testable. How will you know if you have met these requirements? You won’t.</p>
<p style="text-align: justify;"><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Measure.jpg"><img width="640" height="116" src="79994/Measure1.jpg" /></a> <a target="_blank" href="http://en.wikipedia.org/wiki/ISO/IEC_9126" title="SO/IEC 9126 Software engineering - Product quality"></a></p><p style="text-align: justify;"><a target="_blank" href="http://en.wikipedia.org/wiki/ISO/IEC_9126" title="SO/IEC 9126 Software engineering - Product quality">ISO 9126</a> and <a target="_blank" href="http://www.serc.nl/quint-book/" title="QUINT Software Quality Attributes">QUINT</a> both describe ways to quantify the non-functional requirements. For example testability specifies an indicator “number of test cases per unit volume”. QUINT also specifies how you can actually measure an indicator for example the indicator “Ratio Reused Parts” from the quality attribute <a href="http://www.serc.nl/reusability.htm">Reusability</a> which you can&nbsp;measure using the following protocol:</p>
<ol>
<li>Measure the size of each reused part;</li>
<li>Measure the size of the entire software product;</li>
<li>Calculate the ratio of reused parts, which is the sum of reused parts divided by (2).</li>
</ol>
<p><strong>7. Get it working, Get it right, Get it optimized</strong></p>
<p style="text-align: justify;">In many projects I have seen architects and developers design software architectures that focus on creating <strong>general purpose libraries</strong>, services or infrastructure. These are created <strong>without</strong> a direct reference to a <strong>concrete application</strong>. Instead they are designing for tomorrow. This for me is like <strong>walking backwards</strong>, generality cannot be designed <strong>up-front</strong>. If you think, well… stop! you actually can’t. Today’s <strong><span style="font-weight: normal;">businesses change</span> </strong>way too fast to design for generality up-front.</p>
<p style="text-align: justify;">You should always start with a <strong>concrete</strong> implementation for a <strong>specific</strong> problem. At the time you start working on the next application and find similarities, that’s the time to think about generalizing. This makes the first solution simpler, which should be your design goal.</p>
<p><strong>8. Focus on the Boundaries and Interfaces</strong></p>
<p style="text-align: justify;">When creating your software architecture design you should focus on the boundaries of your system and components. When starting blank you should think about separation of concerns. What component or system has which responsibility? Between the components or system design explicit interfaces. Don’t separate a system of component when a lot of communication is necessary between these components or systems.</p>
<p><strong>9. The Perfect is the enemy of the Good</strong></p>
<p style="text-align: justify;">The phrase “The perfect is the enemy of the good” from <a target="_blank" href="http://en.wikiquote.org/wiki/Voltaire" title="The French writer Voltaire">Voltaire</a> is also <strong>valid </strong>for software architecture design. How many times have you started a new project and thought I want this project <strong>to be perfect</strong>? And how many times have you actually found out that the project wasn’t perfect. Well, guess what – a project will never be perfect. There will always be problems or forgotten requirements.</p>
<p><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Perfection.jpg"><img width="426" height="282" src="79994/Perfection1.jpg" /></a></p>
<p style="text-align: justify;">Perfection is never possible. However you are able to create a good <strong>software architecture design</strong>. Do not try to analyze everything during the start of the project it will slow you down. Watch out for <a target="_blank" href="http://en.wikipedia.org/wiki/Analysis_paralysis" title="Analysis Paralysis on WikipediA">Analysis Paralysis</a>.</p>
<p><strong>10. Align with your stakeholders</strong></p>
<p style="text-align: justify;">Before you can create any type of system you need to identify your <strong>stakeholders</strong>. Each stakeholder has different needs of your software architecture and may require a different view. Software developers may need descriptions using <strong>Unified Modeling Language (UML)</strong> while business sponsors need a description in natural language. Operations and support staff for example may need other view such as context diagrams.</p>
<p><a href="http://www.semanticarchitecture.net/wp-content/uploads/2010/05/Stakeholders.jpg"><img width="439" height="150" src="79994/Stakeholders.jpg" /></a></p>
<p style="text-align: justify;">There is a tension between creating all these views for stakeholders and principle <strong>3. Don’t Repeat Yourself</strong>. Each view essentially describe the same system and adds repetition. Therefore you should only add those descriptions that adds value for a specific stakeholder.</p>



<p style="text-align: justify;">Well there you have it, my 10 tips to improve your <strong>Software Architecture Design. </strong> If you have another tip that you use to improve your architecture design let me know in the comment!</p>




</span>
<!-- End Article -->




</div> 
</body>
</html>
